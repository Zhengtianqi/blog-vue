---
title: JVM类加载过程
author: 郑天祺
tag:
  - JVM
category:
  - 面试
date: 2020-09-27 11:08:00

---

# 0、图解

![image-20200927113941669](/assets/images/JVM类加载过程.png)

![image-20210807123832574](/assets/images/image-20210807123832574.png)

# 1、加载

类的加载，分为三步：

（1）通过一个类的全限定名获取该类的二进制流

（2）将该二进制流中的静态存储结构转化为方法去运行时数据结构

（3）在内存中生成该类的Class对象，作为该类的数据访问入口

# 2、验证

验证的目的是为了确保Class文件的字节流的信息不会危害到虚拟机，分为四步：

## （1）文件格式验证：

验证字节流是否符合 Class 文件的规范，如：主次版本号是否在当前虚拟机范围内，常量池中收到常量是否有不被支持的类型。

## （2）元数据验证：

对字节码描述的信息进行语义分析，如果这个类是否有父类，是否集成了不被集成的类。

## （3）字节码验证：

是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。

## （4）符号引用验证：

这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。

# 3、准备

准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

```java
public static int value = 123; 
```

在准备阶段初始值是0，在初始化阶段才会变成123

# 4、解析

该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。

# 5、初始化

初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码

# 6、总结

Java语言是一种具有动态性的解释型语言，类（Class）只有被加载到 JVM 后才能运行。当运行指定程序时，JVM 会将编译生成的 .class 文件按照需求和一定的规则加载到内存中，并组成成为一个完整的 Java 应用程序。

这个加载过程是由类加载器完成，具体来说，就是由ClassLoader和它的子类来实现的，类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。

类的加载方式分为隐式加载和显示加载。隐式加载指的是程序在使用 new 等方式创建对象时，会隐式地调用类的加载器把对应的类 加载到 JVM 中。显示加载指的是通过直接调用 class.forName() 方法来把所需的类加载到 JVM 中。

任何一个工程项目都是由许多类组成的，当程序启动时，只把需要的类加载到 JVM 中，其他类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行时对内存的开销。

此外，在 java 语言中，每个类或接口都对应一个 .class文件，这些文件可以被看成是一个个可以被动态加载的单元，因此当只有部分类被修改时，只需要重新编译变化的类即可，而不需要重新编译所有文件，因此加快了编译速度。

# 7、例子

```java
package com.ztq.clazz;

/**
 * class的加载顺序
 *
 * @author zhengtianqi
 */
public class ClazzLoadSequence {

    static class T1 {
        public static T1 t = new T1(); // step1. count = 0  t = null 只是引用，默认为空
        static int count = 2; // step3. count = 2
		private int m = 8;	// step4. m = 8
        private T1() {
            count++; // step2. count = 1
        }
    }

    static class T2 {
        static int count = 2; // step1. count = 2
        public static T2 t = new T2(); // step2. count = 2

        private T2() {
            count++; // step3. count = 3
        }
    }


    public static void main(String[] args) {
        // 2
        System.out.println(T1.count);
        // 3
        System.out.println(T2.count);
    }

}
```

