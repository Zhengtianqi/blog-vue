---
title: JVM垃圾回收算法
author: 郑天祺
tag:

  - JVM
category:
  - 面试
date: 2020-09-18 09:18:00

---

# 1、标记 - 清除 算法

​	标记无用对象，然后进行清除回收。

​	缺点：效率不高，无法清除垃圾碎片。

![image-20200918092639589](/assets/images/jvm1.png)

# 2、复制 - 清除 算法

​	按照容量划分二个大小相等的内存区域，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

​	缺点：内存使用率不高，只有原来的一半

![image-20200918092729361](/assets/images/jvm2.png)

# 3、标记 - 整理 - 清除 算法

​	标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存

![image-20200918092801239](/assets/images/jvm3.png)

# 4、分代 - 收集算法

​		根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代；

​		新生代基本采用复制算法;

​		老年代采用标记整理算法。

# 5、分代 - 收集算法详解

​	新生代：朝生夕灭的对象（例如：方法的局部变量引用的对象等）。

​    老年代：存活得比较久，但还是要死的对象（例如：缓存对象、单例对象等）。

​    永久代：对象生成后几乎不灭的对象（例如：加载过的类信息）。

![image-20200918094003026](/assets/images/jvmHeapStructure.png)

·································································

堆大小 = 新生代 + 老年代

新生代与老年代的比例 = 1：2

