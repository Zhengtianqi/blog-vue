export const data = JSON.parse("{\"key\":\"v-56aa1363\",\"path\":\"/posts/java/%E8%87%AA%E6%97%8B%E9%94%81.html\",\"title\":\"自旋锁\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"自旋锁\",\"author\":\"郑天祺\",\"tag\":[\"锁\"],\"category\":[\"java基础\"],\"date\":\"2019-08-31T12:54:00.000Z\",\"description\":\"自旋锁 1、自旋锁概念（spinlock） 是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。 获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。 2、自旋锁的优点 : 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://zhengtianqi.gitee.io/blog-vue/posts/java/%E8%87%AA%E6%97%8B%E9%94%81.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"郑天祺的博客\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"自旋锁\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"自旋锁 1、自旋锁概念（spinlock） 是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。 获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。 2、自旋锁的优点 : 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"og:updated_time\",\"content\":\"2023-06-10T12:47:14.000Z\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"郑天祺\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"锁\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2019-08-31T12:54:00.000Z\"}],[\"meta\",{\"property\":\"article:modified_time\",\"content\":\"2023-06-10T12:47:14.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"自旋锁\\\",\\\"image\\\":[\\\"\\\"],\\\"datePublished\\\":\\\"2019-08-31T12:54:00.000Z\\\",\\\"dateModified\\\":\\\"2023-06-10T12:47:14.000Z\\\",\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"郑天祺\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"1、自旋锁概念（spinlock）\",\"slug\":\"_1、自旋锁概念-spinlock\",\"link\":\"#_1、自旋锁概念-spinlock\",\"children\":[]},{\"level\":2,\"title\":\"2、自旋锁的优点 :\",\"slug\":\"_2、自旋锁的优点\",\"link\":\"#_2、自旋锁的优点\",\"children\":[]},{\"level\":2,\"title\":\"3、自旋锁应用 :\",\"slug\":\"_3、自旋锁应用\",\"link\":\"#_3、自旋锁应用\",\"children\":[]},{\"level\":2,\"title\":\"4、简单自旋锁的实现 ：\",\"slug\":\"_4、简单自旋锁的实现\",\"link\":\"#_4、简单自旋锁的实现\",\"children\":[]},{\"level\":2,\"title\":\"5、可重入的自旋锁和不可重入的自旋锁 ：\",\"slug\":\"_5、可重入的自旋锁和不可重入的自旋锁\",\"link\":\"#_5、可重入的自旋锁和不可重入的自旋锁\",\"children\":[]},{\"level\":2,\"title\":\"6、  另有三种常见的形式 :\",\"slug\":\"_6、-另有三种常见的形式\",\"link\":\"#_6、-另有三种常见的形式\",\"children\":[]}],\"git\":{\"createdTime\":1686401234000,\"updatedTime\":1686401234000,\"contributors\":[{\"name\":\"zhengtianqi\",\"email\":\"270490096@qq.com\",\"commits\":1}]},\"readingTime\":{\"minutes\":2.52,\"words\":756},\"filePathRelative\":\"posts/java/自旋锁.md\",\"localizedDate\":\"2019年8月31日\",\"excerpt\":\"<h1> 自旋锁</h1>\\n<h2> 1、自旋锁概念（spinlock）</h2>\\n<p>是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p>\\n<p>获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。</p>\\n<h2> 2、自旋锁的优点 :</h2>\\n<p>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</p>\",\"autoDesc\":true}")
