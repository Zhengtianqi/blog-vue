<template><div><h1 id="_1、什么是hash表" tabindex="-1"><a class="header-anchor" href="#_1、什么是hash表" aria-hidden="true">#</a> 1、什么是hash表</h1>
<p>​		散列表（hash table，也叫哈希表），是根据关键码值（key value）而直接进行访问的数据结构。</p>
<p>​		也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫 散列函数，存放记录的数组叫做散列表。</p>
<p>​		给定表M，存在函数f（key），对于任意给定的关键字值 key，代入函数后若能得到包含改关键字的记录在表中的地址，则称表M为哈希（hash）表，函数 f（key）为哈希（hash）函数。</p>
<h1 id="_2、hash冲突" tabindex="-1"><a class="header-anchor" href="#_2、hash冲突" aria-hidden="true">#</a> 2、hash冲突</h1>
<p>​		对应不同的关键字可能获得相同的 hash 地址，即 key1 ≠ key2，但是f（key1） = f（key2）。这种现象就是冲突，而且这种冲突只能尽可能的减少，不能完全避免。</p>
<p>​		因为哈希函数是从关键字集合和地址集合的映像，通畅关键字集合比较大，而地址集合的元素仅为哈希表中的地址值。</p>
<h1 id="_3、常用的hash函数" tabindex="-1"><a class="header-anchor" href="#_3、常用的hash函数" aria-hidden="true">#</a> 3、常用的hash函数</h1>
<h2 id="_1、直接定址法" tabindex="-1"><a class="header-anchor" href="#_1、直接定址法" aria-hidden="true">#</a> 1、直接定址法</h2>
<p>​		取 key 的线性函数值作为 hash 值，value = a * key + b</p>
<h2 id="_2、除留余数法" tabindex="-1"><a class="header-anchor" href="#_2、除留余数法" aria-hidden="true">#</a> 2、除留余数法</h2>
<p>​		假设数组长度为l，value = key % l</p>
<p>​		这一种散列码实现简单，运用比较多，但是如果输入的元素集合不具有一定的规律，比较容易产生冲突。数组的长度最好是质数，被除数为质数在一定程度上可以缓解数据堆积的问题。</p>
<h2 id="_3、数字分析法" tabindex="-1"><a class="header-anchor" href="#_3、数字分析法" aria-hidden="true">#</a> 3、数字分析法</h2>
<p>​		对关键字进行分析，取关键字的若干位进行或者组合进行hash计算</p>
<h2 id="_4、平方区中法" tabindex="-1"><a class="header-anchor" href="#_4、平方区中法" aria-hidden="true">#</a> 4、平方区中法</h2>
<p>取关键字平方后中间几位作为哈希地址</p>
<h1 id="_4、处理hash冲突的方法" tabindex="-1"><a class="header-anchor" href="#_4、处理hash冲突的方法" aria-hidden="true">#</a> 4、处理hash冲突的方法</h1>
<h2 id="_1、开放定址法" tabindex="-1"><a class="header-anchor" href="#_1、开放定址法" aria-hidden="true">#</a> 1、开放定址法</h2>
<p>​		所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p>
<p>​		fi(key) = ( f(key) + di) MOD m  (di = 1,2,3,......,m-1)</p>
<h2 id="_2、再哈希法" tabindex="-1"><a class="header-anchor" href="#_2、再哈希法" aria-hidden="true">#</a> 2、再哈希法</h2>
<p>​		再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，...... ,等哈希函数</p>
<p>​		计算地址，直到无冲突。</p>
<p>​	（不易发生聚集，但是增加计算时间）</p>
<h2 id="_3、链地址法" tabindex="-1"><a class="header-anchor" href="#_3、链地址法" aria-hidden="true">#</a> 3、链地址法</h2>
<p>​		每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用 next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来。</p>
<p>​		键值对k2，v2与键值对k1，v1通过计算后的索引值都为2，这时及时产生冲突，但是可以通到next 指将 k2，k1所在的节点连接起来，这样就解决了哈希的冲突问题。</p>
<h2 id="_4、建立公共溢出区" tabindex="-1"><a class="header-anchor" href="#_4、建立公共溢出区" aria-hidden="true">#</a> 4、建立公共溢出区</h2>
<p>​		将 哈希表 分为 基本表 和 溢出表两部分</p>
<p>​		凡是和基本表发生冲突的元素，依赖包填入溢出表。</p>
<p>​</p>
</div></template>


