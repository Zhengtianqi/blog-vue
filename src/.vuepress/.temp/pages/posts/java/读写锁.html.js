export const data = JSON.parse("{\"key\":\"v-7809d5c4\",\"path\":\"/posts/java/%E8%AF%BB%E5%86%99%E9%94%81.html\",\"title\":\"读写锁\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"读写锁\",\"author\":\"郑天祺\",\"tag\":[\"锁\"],\"category\":[\"java基础\"],\"date\":\"2019-08-31T13:08:00.000Z\",\"description\":\"4、读写锁 1、读写锁介绍： ​ ReadWriteLock同Lock一样也是一个接口，提供了readLock和writeLock两种锁的操作机制，一个是只读的锁，一个是写锁。 ​ 理论上，读写锁比互斥锁允许对于共享数据更大程度的并发。与互斥锁相比，读写锁是否能够提高性能取决于读写数据的频率、读取和写入操作的持续时间、以及读线程和写线程之间的竞争。 ​ 一些业务场景中，大部分 只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现性能瓶颈的地方。 针对这种读多写少的情况，java还提供了另外一个实现Lock接口的ReentrantReadWriteLock(读写锁)。读写所允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞。\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://zhengtianqi.gitee.io/blog-vue/posts/java/%E8%AF%BB%E5%86%99%E9%94%81.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"郑天祺的博客\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"读写锁\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"4、读写锁 1、读写锁介绍： ​ ReadWriteLock同Lock一样也是一个接口，提供了readLock和writeLock两种锁的操作机制，一个是只读的锁，一个是写锁。 ​ 理论上，读写锁比互斥锁允许对于共享数据更大程度的并发。与互斥锁相比，读写锁是否能够提高性能取决于读写数据的频率、读取和写入操作的持续时间、以及读线程和写线程之间的竞争。 ​ 一些业务场景中，大部分 只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现性能瓶颈的地方。 针对这种读多写少的情况，java还提供了另外一个实现Lock接口的ReentrantReadWriteLock(读写锁)。读写所允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞。\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"og:updated_time\",\"content\":\"2023-06-10T12:47:14.000Z\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"郑天祺\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"锁\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2019-08-31T13:08:00.000Z\"}],[\"meta\",{\"property\":\"article:modified_time\",\"content\":\"2023-06-10T12:47:14.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"读写锁\\\",\\\"image\\\":[\\\"\\\"],\\\"datePublished\\\":\\\"2019-08-31T13:08:00.000Z\\\",\\\"dateModified\\\":\\\"2023-06-10T12:47:14.000Z\\\",\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"郑天祺\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"1、读写锁介绍：\",\"slug\":\"_1、读写锁介绍\",\"link\":\"#_1、读写锁介绍\",\"children\":[]},{\"level\":2,\"title\":\"2、总结：\",\"slug\":\"_2、总结\",\"link\":\"#_2、总结\",\"children\":[]},{\"level\":2,\"title\":\"3、写锁的获取：\",\"slug\":\"_3、写锁的获取\",\"link\":\"#_3、写锁的获取\",\"children\":[]},{\"level\":2,\"title\":\"4、写锁的释放：\",\"slug\":\"_4、写锁的释放\",\"link\":\"#_4、写锁的释放\",\"children\":[]},{\"level\":2,\"title\":\"5、读锁的获取\",\"slug\":\"_5、读锁的获取\",\"link\":\"#_5、读锁的获取\",\"children\":[]},{\"level\":2,\"title\":\"6、读锁的释放\",\"slug\":\"_6、读锁的释放\",\"link\":\"#_6、读锁的释放\",\"children\":[]},{\"level\":2,\"title\":\"7、锁降级\",\"slug\":\"_7、锁降级\",\"link\":\"#_7、锁降级\",\"children\":[]}],\"git\":{\"createdTime\":1686401234000,\"updatedTime\":1686401234000,\"contributors\":[{\"name\":\"zhengtianqi\",\"email\":\"270490096@qq.com\",\"commits\":1}]},\"readingTime\":{\"minutes\":5.21,\"words\":1562},\"filePathRelative\":\"posts/java/读写锁.md\",\"localizedDate\":\"2019年8月31日\",\"excerpt\":\"<h1> 4、读写锁</h1>\\n<h2> 1、读写锁介绍：</h2>\\n<p>​        ReadWriteLock同Lock一样也是一个接口，提供了readLock和writeLock两种锁的操作机制，一个是只读的锁，一个是写锁。</p>\\n<p>​        理论上，读写锁比互斥锁允许对于共享数据更大程度的并发。与互斥锁相比，读写锁是否能够提高性能取决于读写数据的频率、读取和写入操作的持续时间、以及读线程和写线程之间的竞争。</p>\\n<p>​        一些业务场景中，大部分 只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现性能瓶颈的地方。 针对这种读多写少的情况，java还提供了另外一个实现Lock接口的ReentrantReadWriteLock(读写锁)。读写所允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞。</p>\",\"autoDesc\":true}")
