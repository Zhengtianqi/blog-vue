export const data = JSON.parse("{\"key\":\"v-0176754a\",\"path\":\"/posts/spring/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html\",\"title\":\"Spring Bean作用域与生命周期\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"Spring Bean作用域与生命周期\",\"author\":\"郑天祺\",\"tag\":[\"spring\"],\"category\":[\"java基础\"],\"date\":\"2019-11-14T16:52:00.000Z\",\"description\":\"一、Spring Bean生命周期 img 解释： Spring 通过我们的配置，如 @ComponentScan 定义的扫描路径去找到带有 @Component 的类，这个过程就是一个资源定位的过程。 一旦找到了资源，那么它就开始解析，并且将定义的信息保存起来。注意，此时还没有初始化 Bean ，也就没有 Bean 实例，它有的仅仅是 Bean 的定义。 然后就会把 Bean 定义发布到 Spring IoC 容器中，此时，IoC容器也只有 Bean 的定义，还是没有 Bean 的实例生成。 在默认的情况下，Spring会继续去完成Bean的实例化和依赖注入， 这样从IoC容器中就可以得到一个依赖注入完成的Bean。但是，有些Bean会在取的时候才初始化和依赖注入。如下图：\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://zhengtianqi.gitee.io/blog-vue/posts/spring/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"郑天祺的博客\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"Spring Bean作用域与生命周期\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"一、Spring Bean生命周期 img 解释： Spring 通过我们的配置，如 @ComponentScan 定义的扫描路径去找到带有 @Component 的类，这个过程就是一个资源定位的过程。 一旦找到了资源，那么它就开始解析，并且将定义的信息保存起来。注意，此时还没有初始化 Bean ，也就没有 Bean 实例，它有的仅仅是 Bean 的定义。 然后就会把 Bean 定义发布到 Spring IoC 容器中，此时，IoC容器也只有 Bean 的定义，还是没有 Bean 的实例生成。 在默认的情况下，Spring会继续去完成Bean的实例化和依赖注入， 这样从IoC容器中就可以得到一个依赖注入完成的Bean。但是，有些Bean会在取的时候才初始化和依赖注入。如下图：\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"og:updated_time\",\"content\":\"2023-06-10T12:47:14.000Z\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"郑天祺\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"spring\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2019-11-14T16:52:00.000Z\"}],[\"meta\",{\"property\":\"article:modified_time\",\"content\":\"2023-06-10T12:47:14.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"Spring Bean作用域与生命周期\\\",\\\"image\\\":[\\\"\\\"],\\\"datePublished\\\":\\\"2019-11-14T16:52:00.000Z\\\",\\\"dateModified\\\":\\\"2023-06-10T12:47:14.000Z\\\",\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"郑天祺\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"1、使用@Profile\",\"slug\":\"_1、使用-profile\",\"link\":\"#_1、使用-profile\",\"children\":[]},{\"level\":2,\"title\":\"2、使用 Spring EL\",\"slug\":\"_2、使用-spring-el\",\"link\":\"#_2、使用-spring-el\",\"children\":[]}],\"git\":{\"createdTime\":1686401234000,\"updatedTime\":1686401234000,\"contributors\":[{\"name\":\"zhengtianqi\",\"email\":\"270490096@qq.com\",\"commits\":1}]},\"readingTime\":{\"minutes\":2.19,\"words\":658},\"filePathRelative\":\"posts/spring/Spring-Bean生命周期.md\",\"localizedDate\":\"2019年11月15日\",\"excerpt\":\"<h1> 一、Spring Bean生命周期</h1>\\n<figure><img src=\\\"/assets/images/clip_image002.png\\\" alt=\\\"img\\\" tabindex=\\\"0\\\" loading=\\\"lazy\\\"><figcaption>img</figcaption></figure>\\n<p>解释：</p>\\n<ul>\\n<li>\\n<p>Spring 通过我们的配置，如 @ComponentScan 定义的扫描路径去找到带有 @Component     的类，这个过程就是一个资源定位的过程。</p>\\n</li>\\n<li>\\n<p>一旦找到了资源，那么它就开始解析，并且将定义的信息保存起来。注意，此时还没有初始化 Bean ，也就没有 Bean 实例，它有的仅仅是 Bean 的定义。</p>\\n</li>\\n<li>\\n<p>然后就会把 Bean 定义发布到 Spring IoC 容器中，此时，IoC容器也只有 Bean 的定义，还是没有 Bean 的实例生成。</p>\\n<p>在默认的情况下，Spring会继续去完成Bean的实例化和依赖注入， 这样从IoC容器中就可以得到一个依赖注入完成的Bean。但是，有些Bean会在取的时候才初始化和依赖注入。如下图：</p>\\n</li>\\n</ul>\",\"autoDesc\":true}")
