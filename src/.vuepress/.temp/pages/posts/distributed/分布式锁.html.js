export const data = JSON.parse("{\"key\":\"v-89fe1148\",\"path\":\"/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html\",\"title\":\"分布式锁\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"分布式锁\",\"author\":\"ztq\",\"tag\":[\"分布式锁\"],\"category\":[\"分布式\"],\"date\":\"2021-04-18T13:00:00.000Z\",\"description\":\"1、什么是分布式锁？ ​\\t\\t当多个进程在同一个系统中，用分布式锁控制多个进程对资源的访问。传统的单体应用单机部署情况下，可以使用java并发处理相关的API进行互斥控制。分布式系统后由于多线程，多进程分布在不同机器上，使单机部署情况下的并发控制锁策略失效，为了解决跨JVM互斥机制来控制共享资源的访问，这就是分布式锁的来源；分布式锁应用场景大都是高并发、大流量场景。 2、分布式锁实现 （1）、redis分布式锁的实现 加锁机制：根据hash节点选择一个客户端执行lua脚本 锁互斥机制：再来一个客户端执行同样的lua脚本会提示已经存在锁，然后进入循环一直尝试加锁 可重入机制 watch dog自动延期机制 释放锁机制\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://zhengtianqi.gitee.io/blog-vue/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"郑天祺的博客\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"分布式锁\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"1、什么是分布式锁？ ​\\t\\t当多个进程在同一个系统中，用分布式锁控制多个进程对资源的访问。传统的单体应用单机部署情况下，可以使用java并发处理相关的API进行互斥控制。分布式系统后由于多线程，多进程分布在不同机器上，使单机部署情况下的并发控制锁策略失效，为了解决跨JVM互斥机制来控制共享资源的访问，这就是分布式锁的来源；分布式锁应用场景大都是高并发、大流量场景。 2、分布式锁实现 （1）、redis分布式锁的实现 加锁机制：根据hash节点选择一个客户端执行lua脚本 锁互斥机制：再来一个客户端执行同样的lua脚本会提示已经存在锁，然后进入循环一直尝试加锁 可重入机制 watch dog自动延期机制 释放锁机制\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"og:updated_time\",\"content\":\"2023-06-10T12:47:14.000Z\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"ztq\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"分布式锁\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2021-04-18T13:00:00.000Z\"}],[\"meta\",{\"property\":\"article:modified_time\",\"content\":\"2023-06-10T12:47:14.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"分布式锁\\\",\\\"image\\\":[\\\"\\\"],\\\"datePublished\\\":\\\"2021-04-18T13:00:00.000Z\\\",\\\"dateModified\\\":\\\"2023-06-10T12:47:14.000Z\\\",\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"ztq\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"（1）、redis分布式锁的实现\",\"slug\":\"_1-、redis分布式锁的实现\",\"link\":\"#_1-、redis分布式锁的实现\",\"children\":[]},{\"level\":2,\"title\":\"（2）、基于ETCD实现分布式锁分析\",\"slug\":\"_2-、基于etcd实现分布式锁分析\",\"link\":\"#_2-、基于etcd实现分布式锁分析\",\"children\":[]},{\"level\":2,\"title\":\"1）公共方法的提取\",\"slug\":\"_1-公共方法的提取\",\"link\":\"#_1-公共方法的提取\",\"children\":[]},{\"level\":2,\"title\":\"2）实现\",\"slug\":\"_2-实现\",\"link\":\"#_2-实现\",\"children\":[{\"level\":3,\"title\":\"3）加锁&解锁的归一化\",\"slug\":\"_3-加锁-解锁的归一化\",\"link\":\"#_3-加锁-解锁的归一化\",\"children\":[]}]},{\"level\":2,\"title\":\"4）可重入发布式锁实现\",\"slug\":\"_4-可重入发布式锁实现\",\"link\":\"#_4-可重入发布式锁实现\",\"children\":[]},{\"level\":2,\"title\":\"5）分布式自旋锁实现\",\"slug\":\"_5-分布式自旋锁实现\",\"link\":\"#_5-分布式自旋锁实现\",\"children\":[]},{\"level\":2,\"title\":\"6）超时问题\",\"slug\":\"_6-超时问题\",\"link\":\"#_6-超时问题\",\"children\":[]},{\"level\":2,\"title\":\"7）高并发\",\"slug\":\"_7-高并发\",\"link\":\"#_7-高并发\",\"children\":[]}],\"git\":{\"createdTime\":1686401234000,\"updatedTime\":1686401234000,\"contributors\":[{\"name\":\"zhengtianqi\",\"email\":\"270490096@qq.com\",\"commits\":1}]},\"readingTime\":{\"minutes\":18.74,\"words\":5622},\"filePathRelative\":\"posts/distributed/分布式锁.md\",\"localizedDate\":\"2021年4月18日\",\"excerpt\":\"<h1> 1、什么是分布式锁？</h1>\\n<p>​\\t\\t当多个进程在同一个系统中，用分布式锁控制多个进程对资源的访问。传统的单体应用单机部署情况下，可以使用java并发处理相关的API进行互斥控制。分布式系统后由于多线程，多进程分布在不同机器上，使单机部署情况下的并发控制锁策略失效，为了解决跨JVM互斥机制来控制共享资源的访问，这就是分布式锁的来源；分布式锁应用场景大都是高并发、大流量场景。</p>\\n<h1> 2、分布式锁实现</h1>\\n<h2> （1）、redis分布式锁的实现</h2>\\n<ol>\\n<li>\\n<p>加锁机制：根据hash节点选择一个客户端执行lua脚本</p>\\n</li>\\n<li>\\n<p>锁互斥机制：再来一个客户端执行同样的lua脚本会提示已经存在锁，然后进入循环一直尝试加锁</p>\\n</li>\\n<li>\\n<p>可重入机制</p>\\n</li>\\n<li>\\n<p>watch dog自动延期机制</p>\\n</li>\\n<li>\\n<p>释放锁机制</p>\\n</li>\\n</ol>\",\"autoDesc\":true}")
