import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o,c as p,b as a,d as e,e as t,a as d}from"./app-0ce632a0.js";const s="/blog-vue/assets/images/雪花算法.png",h="/blog-vue/assets/images/数据库分布式ID生成.png",c={},l=d('<h1 id="一、需求" tabindex="-1"><a class="header-anchor" href="#一、需求" aria-hidden="true">#</a> 一、需求</h1><p>在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。</p><p>当需要将节点之间在不同时间的交互做唯一标识，数据日渐增长，</p><p>对数据库的分库分表后需要有一个唯一ID来标识一条数据或消息，数据库的自增ID显然不能满足需求。</p><p>此时一个能够生成全局唯一ID的系统是非常必要的。</p><h1 id="二、id生成的原则" tabindex="-1"><a class="header-anchor" href="#二、id生成的原则" aria-hidden="true">#</a> 二、ID生成的原则：</h1><p>1、全局唯一性：不能出现重复的ID（最基本的要求）</p><p>2、高性能，低延迟。（不要太繁杂的算法）</p><p>3、易于存储，（占用较低的空间）</p><h1 id="三、相对应的算法" tabindex="-1"><a class="header-anchor" href="#三、相对应的算法" aria-hidden="true">#</a> 三、相对应的算法：</h1><h2 id="_1、雪花算法-snowflake" tabindex="-1"><a class="header-anchor" href="#_1、雪花算法-snowflake" aria-hidden="true">#</a> 1、雪花算法 snowflake</h2><figure><img src="'+s+'" alt="1570599617667" tabindex="0" loading="lazy"><figcaption>1570599617667</figcaption></figure><p>1位标识：由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0</p><p>41位时间戳：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的。可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69</p><p>10位机器标识码：可以部署在1024个节点（2^10=1024），如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成。（但是这个也是会重复的网上说法木有参考性，可以改为TPM安全芯片、网卡等的唯一标识码，原则上他们是全球唯一的）</p><p>12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号</p><h3 id="_1-优点" tabindex="-1"><a class="header-anchor" href="#_1-优点" aria-hidden="true">#</a> <strong>（1）优点：</strong></h3><p>时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增。（排序方便，会有很多好处）</p><p>灵活度高，可以根据业务需求，调整bit位的划分</p><p>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的（多一个依赖的组件，多一个风险，并增加了系统的复杂性）</p><h3 id="_2-缺点" tabindex="-1"><a class="header-anchor" href="#_2-缺点" aria-hidden="true">#</a> <strong>（2）缺点：</strong></h3><p>依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成。（网上有优化时钟回拨问题利用记录最后一次成ID的时间，也可利用zookeeper、redis中间件）</p><p>在分布式环境上，每个服务器的时钟不可能完全同步，有时会出现不是全局递增的情况。</p><p>应用举例：</p><p>Mongdb objectID</p><p>可以算作是和snowflake类似方法，通过“时间+机器码+pid+inc”共12个字节，通过4+3+2+3的方式最终标识成一个24长度的十六进制字符。</p><h2 id="_2、uuid" tabindex="-1"><a class="header-anchor" href="#_2、uuid" aria-hidden="true">#</a> 2、UUID</h2><p>UUID是Universally Unique Identifier的缩写，它是在一定的范围内（从特定的名字空间到全球）唯一的机器生成的标识符。（微软叫GUID：Globally Unique Identifier）</p><p>为了保证UUID的唯一性，规范定义了包括网卡MAC地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，以及从这些元素生成UUID的算法。UUID的复杂特性在保证了其唯一性的同时，意味着只能由计算机生成。</p><p>（1）基于时间的UUID</p><p>基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。由于在算法中使用了MAC地址，这个版本的UUID可以保证在全球范围的唯一性。但与此同时，使用MAC地址会带来安全性问题（曾被用于寻找梅丽莎病毒的制作者位置）。如果应用只是在局域网中使用，也可以使用退化的算法，以IP地址来代替MAC地址－－Java的UUID往往是这样实现的（当然也考虑了获取MAC的难度）。</p><p>（2）DCE安全的UUID</p><p>DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。</p><p>（3）基于名字的UUID（MD5）</p><p>基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。</p><p>（4) 随机UUID</p><p>根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但随机的东西就像是买彩票：你指望它发财是不可能的，但狗屎运通常会在不经意中到来。</p><p>(5) 基于名字的UUID（SHA1）</p><p>和版本3的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。</p><h3 id="_1-优点-1" tabindex="-1"><a class="header-anchor" href="#_1-优点-1" aria-hidden="true">#</a> (1) 优点：</h3><p>性能非常高：本地生成，没有网络消耗。</p><h3 id="_2-缺点-1" tabindex="-1"><a class="header-anchor" href="#_2-缺点-1" aria-hidden="true">#</a> (2) 缺点：</h3><p>不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用</p><p>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露</p><p>ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用（mysql主键索引是B+树，推荐使用自增存储效率高）</p><h2 id="_3、利用数据库" tabindex="-1"><a class="header-anchor" href="#_3、利用数据库" aria-hidden="true">#</a> 3、利用数据库</h2><p>步长需设置为N，每台的初始值依次为0,1,2…N-1那么整个架构就变成了如下图所示：</p><figure><img src="'+h+'" alt="1570600564344" tabindex="0" loading="lazy"><figcaption>1570600564344</figcaption></figure><p>美团Leaf-segment方案直接取一批号段，用完再取一批号段，避免每次都去请求数据库导致连接数和线程数过大。</p><h1 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档" aria-hidden="true">#</a> 参考文档：</h1>',50),I={href:"https://docs.mongodb.com/manual/reference/method/ObjectId/#description",target:"_blank",rel:"noopener noreferrer"},_={href:"https://tech.meituan.com/2017/04/21/mt-leaf.html",target:"_blank",rel:"noopener noreferrer"},D={href:"https://blog.csdn.net/u012488504/article/details/82194495",target:"_blank",rel:"noopener noreferrer"},U={href:"https://baike.baidu.com/item/%E6%A2%85%E4%B8%BD%E8%8E%8E%E7%97%85%E6%AF%92/9739231",target:"_blank",rel:"noopener noreferrer"},f={href:"https://www.cnblogs.com/moyand/p/9013663.html",target:"_blank",rel:"noopener noreferrer"};function m(b,u){const r=i("ExternalLinkIcon");return o(),p("div",null,[l,a("p",null,[e("Mongdb objectID: "),a("a",I,[e("https://docs.mongodb.com/manual/reference/method/ObjectId/#description"),t(r)]),e(" Leaf——美团点评分布式ID生成系统: "),a("a",_,[e("https://tech.meituan.com/2017/04/21/mt-leaf.html"),t(r)]),e(" 分布式ID生成 - 雪花算法: "),a("a",D,[e("https://blog.csdn.net/u012488504/article/details/82194495"),t(r)]),e(" 梅丽莎病毒: "),a("a",U,[e("https://baike.baidu.com/item/梅丽莎病毒/9739231"),t(r)]),e(" mysql中InnoDB表为什么要建议用自增列做主键: "),a("a",f,[e("https://www.cnblogs.com/moyand/p/9013663.html"),t(r)])])])}const k=n(c,[["render",m],["__file","分布式全局唯一ID生成策略.html.vue"]]);export{k as default};
