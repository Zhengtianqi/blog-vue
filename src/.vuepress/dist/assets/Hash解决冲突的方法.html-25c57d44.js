import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as h,c as e,a as r}from"./app-0ce632a0.js";const d={},i=r('<h1 id="_1、什么是hash表" tabindex="-1"><a class="header-anchor" href="#_1、什么是hash表" aria-hidden="true">#</a> 1、什么是hash表</h1><p>​ 散列表（hash table，也叫哈希表），是根据关键码值（key value）而直接进行访问的数据结构。</p><p>​ 也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫 散列函数，存放记录的数组叫做散列表。</p><p>​ 给定表M，存在函数f（key），对于任意给定的关键字值 key，代入函数后若能得到包含改关键字的记录在表中的地址，则称表M为哈希（hash）表，函数 f（key）为哈希（hash）函数。</p><h1 id="_2、hash冲突" tabindex="-1"><a class="header-anchor" href="#_2、hash冲突" aria-hidden="true">#</a> 2、hash冲突</h1><p>​ 对应不同的关键字可能获得相同的 hash 地址，即 key1 ≠ key2，但是f（key1） = f（key2）。这种现象就是冲突，而且这种冲突只能尽可能的减少，不能完全避免。</p><p>​ 因为哈希函数是从关键字集合和地址集合的映像，通畅关键字集合比较大，而地址集合的元素仅为哈希表中的地址值。</p><h1 id="_3、常用的hash函数" tabindex="-1"><a class="header-anchor" href="#_3、常用的hash函数" aria-hidden="true">#</a> 3、常用的hash函数</h1><h2 id="_1、直接定址法" tabindex="-1"><a class="header-anchor" href="#_1、直接定址法" aria-hidden="true">#</a> 1、直接定址法</h2><p>​ 取 key 的线性函数值作为 hash 值，value = a * key + b</p><h2 id="_2、除留余数法" tabindex="-1"><a class="header-anchor" href="#_2、除留余数法" aria-hidden="true">#</a> 2、除留余数法</h2><p>​ 假设数组长度为l，value = key % l</p><p>​ 这一种散列码实现简单，运用比较多，但是如果输入的元素集合不具有一定的规律，比较容易产生冲突。数组的长度最好是质数，被除数为质数在一定程度上可以缓解数据堆积的问题。</p><h2 id="_3、数字分析法" tabindex="-1"><a class="header-anchor" href="#_3、数字分析法" aria-hidden="true">#</a> 3、数字分析法</h2><p>​ 对关键字进行分析，取关键字的若干位进行或者组合进行hash计算</p><h2 id="_4、平方区中法" tabindex="-1"><a class="header-anchor" href="#_4、平方区中法" aria-hidden="true">#</a> 4、平方区中法</h2><p>取关键字平方后中间几位作为哈希地址</p><h1 id="_4、处理hash冲突的方法" tabindex="-1"><a class="header-anchor" href="#_4、处理hash冲突的方法" aria-hidden="true">#</a> 4、处理hash冲突的方法</h1><h2 id="_1、开放定址法" tabindex="-1"><a class="header-anchor" href="#_1、开放定址法" aria-hidden="true">#</a> 1、开放定址法</h2><p>​ 所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p><p>​ fi(key) = ( f(key) + di) MOD m (di = 1,2,3,......,m-1)</p><h2 id="_2、再哈希法" tabindex="-1"><a class="header-anchor" href="#_2、再哈希法" aria-hidden="true">#</a> 2、再哈希法</h2><p>​ 再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，...... ,等哈希函数</p><p>​ 计算地址，直到无冲突。</p><p>​ （不易发生聚集，但是增加计算时间）</p><h2 id="_3、链地址法" tabindex="-1"><a class="header-anchor" href="#_3、链地址法" aria-hidden="true">#</a> 3、链地址法</h2><p>​ 每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用 next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来。</p><p>​ 键值对k2，v2与键值对k1，v1通过计算后的索引值都为2，这时及时产生冲突，但是可以通到next 指将 k2，k1所在的节点连接起来，这样就解决了哈希的冲突问题。</p><h2 id="_4、建立公共溢出区" tabindex="-1"><a class="header-anchor" href="#_4、建立公共溢出区" aria-hidden="true">#</a> 4、建立公共溢出区</h2><p>​ 将 哈希表 分为 基本表 和 溢出表两部分</p><p>​ 凡是和基本表发生冲突的元素，依赖包填入溢出表。</p><p>​</p>',32),s=[i];function n(t,_){return h(),e("div",null,s)}const o=a(d,[["render",n],["__file","Hash解决冲突的方法.html.vue"]]);export{o as default};
