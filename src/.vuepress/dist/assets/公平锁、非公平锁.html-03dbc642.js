import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as r,c as _,b as e,d as t,e as n}from"./app-0ce632a0.js";const c={},a=e("p",null,"1、概念：",-1),p=e("p",null,"​ 公平锁：加锁前先查看是否有排队等待的线程，有的话优先处理排在前面的线程，先来先得。 ​ 公平所：线程加锁时直接尝试获取锁，获取不到就自动到队尾等待。",-1),h=e("p",null,"​ 更多的是直接使用非公平锁：非公平锁比公平锁性能高5-10倍，因为公平锁需要在多核情况下维护一个队列，如果当前线程不是队列的第一个无法获取锁，增加了线程切换次数。",-1),i={href:"https://www.cnblogs.com/little-fly/p/10365109.html",target:"_blank",rel:"noopener noreferrer"},d={href:"https://www.jianshu.com/p/06340f8feb05",target:"_blank",rel:"noopener noreferrer"},f=e("p",null,"​",-1),m=e("p",null,"2、Java语言中:",-1),u=e("p",null,"​ 公平和非公平锁的队列都基于锁内部维护的一个双向链表，表结点Node的值就是每一个请求当前锁的线程。",-1),w={href:"https://www.jianshu.com/p/c7d17b5c6be3",target:"_blank",rel:"noopener noreferrer"};function b(k,x){const o=s("ExternalLinkIcon");return r(),_("div",null,[a,p,h,e("p",null,[t("​ 原理 ： "),e("a",i,[t("https://www.cnblogs.com/little-fly/p/10365109.html"),n(o)])]),e("p",null,[t("​ "),e("a",d,[t("https://www.jianshu.com/p/06340f8feb05"),n(o)])]),f,m,u,e("p",null,[t("​ 两者的区别："),e("a",w,[t("https://www.jianshu.com/p/c7d17b5c6be3"),n(o)])])])}const v=l(c,[["render",b],["__file","公平锁、非公平锁.html.vue"]]);export{v as default};
